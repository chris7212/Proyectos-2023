"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binarySearch = void 0;
class KeyedDB {
    /**
     *
     * @param key Return the unique key used to sort items
     * @param id The unique ID for the items
     */
    constructor(key, id) {
        this.key = key;
        this.idGetter = id || (v => key(v).toString());
        this.dict = {};
        this.array = [];
    }
    insert(value) {
        if (!value)
            throw new Error('undefined value');
        if (this.array.length > 0) {
            const index = this.firstIndex(value);
            if (index >= this.array.length)
                this.array.push(value);
            else if (index < 0)
                this.array.unshift(value);
            else if (this.key(value) !== this.key(this.array[index]))
                this.array.splice(index, 0, value);
            else
                throw new Error(`duplicate key: ${this.key(value)}, values: ${JSON.stringify(value)}, ${JSON.stringify(this.array[index])}`);
        }
        else {
            this.array.push(value);
        }
        this.dict[this.idGetter(value)] = value;
    }
    delete(value) {
        const index = this.firstIndex(value);
        if (index < 0 || index >= this.array.length || this.key(value) !== this.key(this.array[index])) {
            return null;
        }
        delete this.dict[this.idGetter(value)];
        return this.array.splice(index, 1)[0];
    }
    clear() {
        this.array = [];
        this.dict = {};
    }
    get(id) {
        return this.dict[id];
    }
    all() {
        return this.array;
    }
    updateKey(value, update) {
        this.delete(value);
        update(value);
        this.insert(value);
    }
    paginatedByValue(value, limit) {
        return this.paginated(value && this.key(value), limit);
    }
    paginated(cursor, limit) {
        if (!cursor)
            return this.array.slice(0, limit);
        const index = binarySearch(this.array, v => cursor - this.key(v));
        if (index < 0)
            return this.array.slice(0, limit);
        else if (index >= this.array.length)
            return [];
        let chats = this.array.slice(index, index + limit);
        if (this.key(chats[0]) === cursor)
            chats = chats.slice(1);
        return chats;
    }
    firstIndex(value) {
        return binarySearch(this.array, v => this.key(value) - this.key(v));
    }
}
exports.default = KeyedDB;
/**
 *
 * @param array the array to search in
 * @param predicate return a value of < 0, if the item you're looking for should come before, 0 if it is the item you're looking for
 */
function binarySearch(array, predicate) {
    let low = 0;
    let high = array.length;
    if (array.length === 0)
        return low;
    if (predicate(array[low]) < 0)
        return low - 1;
    else if (predicate(array[low]) === 0)
        return low;
    const maxPred = predicate(array[high - 1]);
    if (maxPred > 0)
        return high;
    else if (maxPred === 0)
        return high - 1;
    while (low !== high) {
        const mid = low + Math.floor((high - low) / 2);
        const pred = predicate(array[mid]);
        if (pred < 0)
            high = mid;
        else if (pred > 0)
            low = mid + 1;
        else
            return mid;
    }
    return low;
}
exports.binarySearch = binarySearch;

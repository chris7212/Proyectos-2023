"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptWA = exports.generateMessageID = exports.generateClientID = exports.generateMessageTag = exports.promiseTimeout = exports.createTimeout = exports.randomBytes = exports.hkdf = exports.sha256 = exports.hmacSign = exports.aesEncrypWithIV = exports.aesEncrypt = exports.aesDecryptWithIV = exports.aesDecrypt = exports.userAgentString = exports.waChatUniqueKey = exports.Browsers = void 0;
const Crypto = __importStar(require("crypto"));
const futoin_hkdf_1 = __importDefault(require("futoin-hkdf"));
const os_1 = require("os");
const Constants_1 = require("./Constants");
const user_agents_1 = __importDefault(require("user-agents"));
const platformMap = {
    'aix': 'AIX',
    'darwin': 'Mac OS',
    'win32': 'Windows',
    'android': 'Android'
};
exports.Browsers = {
    ubuntu: browser => ['Ubuntu', browser, '18.04'],
    macOS: browser => ['Mac OS', browser, '10.15.3'],
    baileys: browser => ['Baileys', browser, '2.0'],
    /** The appropriate browser based on your OS & release */
    appropriate: browser => [platformMap[os_1.platform()] || 'Ubuntu', browser, os_1.release()]
};
function hashCode(s) {
    for (var i = 0, h = 0; i < s.length; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
    return h;
}
exports.waChatUniqueKey = (c) => ((+c.t * 1000) + (hashCode(c.jid) % 1000)) * -1; // -1 to sort descending
function userAgentString(browser) {
    const agent = new user_agents_1.default(new RegExp(browser));
    return agent.toString();
}
exports.userAgentString = userAgentString;
/** decrypt AES 256 CBC; where the IV is prefixed to the buffer */
function aesDecrypt(buffer, key) {
    return aesDecryptWithIV(buffer.slice(16, buffer.length), key, buffer.slice(0, 16));
}
exports.aesDecrypt = aesDecrypt;
/** decrypt AES 256 CBC */
function aesDecryptWithIV(buffer, key, IV) {
    const aes = Crypto.createDecipheriv('aes-256-cbc', key, IV);
    return Buffer.concat([aes.update(buffer), aes.final()]);
}
exports.aesDecryptWithIV = aesDecryptWithIV;
// encrypt AES 256 CBC; where a random IV is prefixed to the buffer
function aesEncrypt(buffer, key) {
    const IV = randomBytes(16);
    const aes = Crypto.createCipheriv('aes-256-cbc', key, IV);
    return Buffer.concat([IV, aes.update(buffer), aes.final()]); // prefix IV to the buffer
}
exports.aesEncrypt = aesEncrypt;
// encrypt AES 256 CBC with a given IV
function aesEncrypWithIV(buffer, key, IV) {
    const aes = Crypto.createCipheriv('aes-256-cbc', key, IV);
    return Buffer.concat([aes.update(buffer), aes.final()]); // prefix IV to the buffer
}
exports.aesEncrypWithIV = aesEncrypWithIV;
// sign HMAC using SHA 256
function hmacSign(buffer, key) {
    return Crypto.createHmac('sha256', key).update(buffer).digest();
}
exports.hmacSign = hmacSign;
function sha256(buffer) {
    return Crypto.createHash('sha256').update(buffer).digest();
}
exports.sha256 = sha256;
// HKDF key expansion
function hkdf(buffer, expandedLength, info = null) {
    return futoin_hkdf_1.default(buffer, expandedLength, { salt: Buffer.alloc(32), info: info, hash: 'SHA-256' });
}
exports.hkdf = hkdf;
// generate a buffer with random bytes of the specified length
function randomBytes(length) {
    return Crypto.randomBytes(length);
}
exports.randomBytes = randomBytes;
exports.createTimeout = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));
async function promiseTimeout(ms, promise) {
    if (!ms)
        return promise;
    // Create a promise that rejects in <ms> milliseconds
    let timeoutI;
    const timeout = new Promise((_, reject) => timeoutI = setTimeout(() => reject(new Constants_1.BaileysError('Timed out', promise)), ms));
    try {
        const content = await Promise.race([promise, timeout]);
        return content;
    }
    finally {
        clearTimeout(timeoutI);
    }
}
exports.promiseTimeout = promiseTimeout;
// whatsapp requires a message tag for every message, we just use the timestamp as one
function generateMessageTag(epoch) {
    let tag = Math.round(new Date().getTime() / 1000).toString();
    if (epoch)
        tag += '.--' + epoch; // attach epoch if provided
    return tag;
}
exports.generateMessageTag = generateMessageTag;
// generate a random 16 byte client ID
function generateClientID() {
    return randomBytes(16).toString('base64');
}
exports.generateClientID = generateClientID;
// generate a random 10 byte ID to attach to a message
function generateMessageID() {
    return randomBytes(10).toString('hex').toUpperCase();
}
exports.generateMessageID = generateMessageID;
function decryptWA(message, macKey, encKey, decoder, fromMe = false) {
    let commaIndex = message.indexOf(','); // all whatsapp messages have a tag and a comma, followed by the actual message
    if (commaIndex < 0)
        throw Error('invalid message: ' + message); // if there was no comma, then this message must be not be valid
    if (message[commaIndex + 1] === ',')
        commaIndex += 1;
    let data = message.slice(commaIndex + 1, message.length);
    // get the message tag.
    // If a query was done, the server will respond with the same message tag we sent the query with
    const messageTag = message.slice(0, commaIndex).toString();
    if (data.length === 0) {
        // got an empty message, usually get one after sending a query with the 128 tag
        return;
    }
    let json;
    let tags = null;
    if (data[0] === '[' || data[0] === '{') {
        // if the first character is a "[", then the data must just be plain JSON array or object
        json = JSON.parse(data); // parse the JSON
    }
    else {
        if (!macKey || !encKey) {
            // if we recieved a message that was encrypted but we don't have the keys, then there must be an error
            throw new Error('recieved encrypted buffer when auth creds unavailable');
        }
        /*
            If the data recieved was not a JSON, then it must be an encrypted message.
            Such a message can only be decrypted if we're connected successfully to the servers & have encryption keys
        */
        if (fromMe) {
            tags = [data[0], data[1]];
            data = data.slice(2, data.length);
        }
        const checksum = data.slice(0, 32); // the first 32 bytes of the buffer are the HMAC sign of the message
        data = data.slice(32, data.length); // the actual message
        const computedChecksum = hmacSign(data, macKey); // compute the sign of the message we recieved using our macKey
        if (!checksum.equals(computedChecksum)) {
            throw new Error(`Checksums don't match:\nog: ${checksum.toString('hex')}\ncomputed: ${computedChecksum.toString('hex')}`);
        }
        // the checksum the server sent, must match the one we computed for the message to be valid
        const decrypted = aesDecrypt(data, encKey); // decrypt using AES
        json = decoder.read(decrypted); // decode the binary message into a JSON array
    }
    return [messageTag, json, tags];
}
exports.decryptWA = decryptWA;

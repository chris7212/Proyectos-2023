"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const Utils_1 = require("./Utils");
const Decoder_1 = __importDefault(require("../Binary/Decoder"));
const file = fs_1.default.readFileSync('./browser-messages.json', { encoding: 'utf-8' });
const json = JSON.parse(file);
const encKey = Buffer.from(json.encKey, 'base64');
const macKey = Buffer.from(json.macKey, 'base64');
const harFile = JSON.parse(fs_1.default.readFileSync(json.harFilePath, { encoding: 'utf-8' }));
const entries = harFile['log']['entries'];
let wsMessages = [];
entries.forEach((e, i) => {
    if ('_webSocketMessages' in e) {
        wsMessages.push(...e['_webSocketMessages']);
    }
});
const decrypt = buffer => {
    try {
        return Utils_1.decryptWA(buffer, macKey, encKey, new Decoder_1.default());
    }
    catch (_a) {
        return Utils_1.decryptWA(buffer, macKey, encKey, new Decoder_1.default(), true);
    }
};
console.log('parsing ' + wsMessages.length + ' messages');
const list = wsMessages.map((item, i) => {
    const buffer = Buffer.from(item.data, 'base64');
    try {
        const [tag, json, binaryTags] = decrypt(buffer);
        return { tag, json: JSON.stringify(json), binaryTags };
    }
    catch (error) {
        try {
            const [tag, json, binaryTags] = decrypt(item.data);
            return { tag, json: JSON.stringify(json), binaryTags };
        }
        catch (error) {
            console.log('error in decoding: ' + item.data + ': ' + error);
            return null;
        }
    }
});
const str = JSON.stringify(list, null, '\t');
fs_1.default.writeFileSync('decoded-ws.json', str);

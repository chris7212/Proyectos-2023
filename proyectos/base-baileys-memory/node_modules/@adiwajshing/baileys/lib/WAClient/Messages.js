"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Groups_1 = __importDefault(require("./Groups"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const fs_1 = require("fs");
const Constants_1 = require("./Constants");
const Utils_1 = require("../WAConnection/Utils");
const Constants_2 = require("../WAConnection/Constants");
const Utils_2 = require("./Utils");
const WAMessage_1 = require("../../WAMessage/WAMessage");
class WhatsAppWebMessages extends Groups_1.default {
    /** Get the message info, who has read it, who its been delivered to */
    async messageInfo(jid, messageID) {
        const query = ['query', { type: 'message_info', index: messageID, jid: jid, epoch: this.msgCount.toString() }, null];
        const response = (await this.queryExpecting200(query, [22, Constants_2.WAFlag.ignore]))[2];
        const info = { reads: [], deliveries: [] };
        if (response) {
            //console.log (response)
            const reads = response.filter(node => node[0] === 'read');
            if (reads[0]) {
                info.reads = reads[0][2].map(item => item[1]);
            }
            const deliveries = response.filter(node => node[0] === 'delivery');
            if (deliveries[0]) {
                info.deliveries = deliveries[0][2].map(item => item[1]);
            }
        }
        return info;
    }
    /**
     * Send a read receipt to the given ID for a certain message
     * @param jid the ID of the person/group whose message you want to mark read
     * @param messageID optionally, the message ID
     * @param type whether to read or unread the message
     */
    async sendReadReceipt(jid, messageID, type = 'read') {
        const attributes = {
            jid: jid,
            count: type === 'read' ? '1' : '-2',
            index: messageID,
            owner: messageID ? 'false' : null
        };
        return this.setQuery([['read', attributes, null]]);
    }
    /**
     * Mark a given chat as unread
     * @deprecated since 2.0.0, use `sendReadReceipt (jid, null, 'unread')` instead
    */
    async markChatUnread(jid) { return this.sendReadReceipt(jid, null, 'unread'); }
    /**
     * Archive a chat
     * @deprecated since 2.0.0, use `modifyChat (jid, ChatModification.archive)` instead
    */
    async archiveChat(jid) { return this.modifyChat(jid, Constants_1.ChatModification.archive); }
    /**
     * Modify a given chat (archive, pin etc.)
     * @param jid the ID of the person/group you are modifiying
     * @param options.stamp the timestamp of pinning/muting the chat. Is required when unpinning/unmuting
     */
    async modifyChat(jid, type, options = { stamp: new Date() }) {
        let chatAttrs = { jid: jid };
        if ((type === Constants_1.ChatModification.unpin || type === Constants_1.ChatModification.unmute) && !(options === null || options === void 0 ? void 0 : options.stamp)) {
            throw new Error('options.stamp must be set to the timestamp of the time of pinning/unpinning of the chat');
        }
        const strStamp = options.stamp &&
            (typeof options.stamp === 'string' ? options.stamp : Math.round(options.stamp.getTime() / 1000).toString());
        switch (type) {
            case Constants_1.ChatModification.pin:
            case Constants_1.ChatModification.mute:
                chatAttrs.type = type;
                chatAttrs[type] = strStamp;
                break;
            case Constants_1.ChatModification.unpin:
            case Constants_1.ChatModification.unmute:
                chatAttrs.type = type.replace('un', ''); // replace 'unpin' with 'pin'
                chatAttrs.previous = strStamp;
                break;
            default:
                chatAttrs.type = type;
                break;
        }
        let response = await this.setQuery([['chat', chatAttrs, null]]);
        response.stamp = strStamp;
        return response;
    }
    async loadMessage(jid, messageID) {
        let messages;
        try {
            messages = await this.loadConversation(jid, 1, { id: messageID, fromMe: true }, false);
        }
        catch (_a) {
            messages = await this.loadConversation(jid, 1, { id: messageID, fromMe: false }, false);
        }
        var index = null;
        if (messages.length > 0)
            index = messages[0].key;
        const actual = await this.loadConversation(jid, 1, index);
        return actual[0];
    }
    /** Query a string to check if it has a url, if it does, return required extended text message */
    async generateLinkPreview(text) {
        const query = ['query', { type: 'url', url: text, epoch: this.msgCount.toString() }, null];
        const response = await this.queryExpecting200(query, [26, Constants_2.WAFlag.ignore]);
        if (response[1])
            response[1].jpegThumbnail = response[2];
        const data = response[1];
        const content = { text };
        content.canonicalUrl = data['canonical-url'];
        content.matchedText = data['matched-text'];
        content.jpegThumbnail = data.jpegThumbnail;
        content.description = data.description;
        content.title = data.title;
        content.previewType = 0;
        return content;
    }
    /**
     * Search WhatsApp messages with a given text string
     * @param txt the search string
     * @param inJid the ID of the chat to search in, set to null to search all chats
     * @param count number of results to return
     * @param page page number of results (starts from 1)
     */
    async searchMessages(txt, inJid, count, page) {
        const json = [
            'query',
            {
                epoch: this.msgCount.toString(),
                type: 'search',
                search: txt,
                count: count.toString(),
                page: page.toString(),
                jid: inJid
            },
            null,
        ];
        const response = await this.queryExpecting200(json, [Constants_2.WAMetric.group, Constants_2.WAFlag.ignore]); // encrypt and send  off
        const messages = response[2] ? response[2].map(row => row[2]) : [];
        return { last: response[1]['last'] === 'true', messages: messages };
    }
    /**
     * Delete a message in a chat for yourself
     * @param messageKey key of the message you want to delete
     */
    async clearMessage(messageKey) {
        const tag = Math.round(Math.random() * 1000000);
        const attrs = [
            'chat',
            { jid: messageKey.remoteJid, modify_tag: tag.toString(), type: 'clear' },
            [
                ['item', { owner: `${messageKey.fromMe}`, index: messageKey.id }, null]
            ]
        ];
        return this.setQuery([attrs]);
    }
    /**
     * Fetches the latest url & media key for the given message.
     * You may need to call this when the message is old & the content is deleted off of the WA servers
     * @param message
     */
    async updateMediaMessage(message) {
        var _a, _b, _c, _d, _e;
        const content = ((_a = message.message) === null || _a === void 0 ? void 0 : _a.audioMessage) || ((_b = message.message) === null || _b === void 0 ? void 0 : _b.videoMessage) || ((_c = message.message) === null || _c === void 0 ? void 0 : _c.imageMessage) || ((_d = message.message) === null || _d === void 0 ? void 0 : _d.stickerMessage) || ((_e = message.message) === null || _e === void 0 ? void 0 : _e.documentMessage);
        if (!content)
            throw new Constants_2.BaileysError(`given message ${message.key.id} is not a media message`, message);
        const query = ['query', { type: 'media', index: message.key.id, owner: message.key.fromMe ? 'true' : 'false', jid: message.key.remoteJid, epoch: this.msgCount.toString() }, null];
        const response = await this.query(query, [Constants_2.WAMetric.queryMedia, Constants_2.WAFlag.ignore]);
        if (parseInt(response[1].code) !== 200)
            throw new Constants_2.BaileysError('unexpected status ' + response[1].code, response);
        Object.keys(response[1]).forEach(key => content[key] = response[1][key]); // update message
    }
    /**
     * Delete a message in a chat for everyone
     * @param id the person or group where you're trying to delete the message
     * @param messageKey key of the message you want to delete
     */
    async deleteMessage(id, messageKey) {
        const json = {
            protocolMessage: {
                key: messageKey,
                type: WAMessage_1.proto.ProtocolMessage.PROTOCOL_MESSAGE_TYPE.REVOKE
            }
        };
        return this.sendMessageContent(id, json, {});
    }
    /**
     * Forward a message like WA does
     * @param id the id to forward the message to
     * @param message the message to forward
     */
    async forwardMessage(id, message) {
        var _a;
        const content = message.message;
        if (!content)
            throw new Error('no content in message');
        let key = Object.keys(content)[0];
        let score = ((_a = content[key].contextInfo) === null || _a === void 0 ? void 0 : _a.forwardingScore) || 0;
        score += message.key.fromMe ? 0 : 1;
        if (key === Constants_1.MessageType.text) {
            content[Constants_1.MessageType.extendedText] = { text: content[key] };
            delete content[Constants_1.MessageType.text];
            key = Constants_1.MessageType.extendedText;
        }
        if (score > 0)
            content[key].contextInfo = { forwardingScore: score, isForwarded: true };
        else
            content[key].contextInfo = {};
        return this.sendMessageContent(id, content, {});
    }
    async sendMessage(id, message, type, options = {}) {
        if (options.validateID === true || !('validateID' in options)) {
            Utils_2.validateJIDForSending(id);
        }
        let m = {};
        switch (type) {
            case Constants_1.MessageType.text:
            case Constants_1.MessageType.extendedText:
                if (typeof message === 'string') {
                    m.extendedTextMessage = { text: message };
                }
                else if ('text' in message) {
                    m.extendedTextMessage = message;
                }
                else {
                    throw new Constants_2.BaileysError('message needs to be a string or object with property \'text\'', message);
                }
                break;
            case Constants_1.MessageType.location:
            case Constants_1.MessageType.liveLocation:
                m.locationMessage = message;
                break;
            case Constants_1.MessageType.contact:
                m.contactMessage = message;
                break;
            default:
                m = await this.prepareMediaMessage(message, type, options);
                break;
        }
        return this.sendMessageContent(id, m, options);
    }
    /** Prepare a media message for sending */
    async prepareMediaMessage(buffer, mediaType, options = {}) {
        if (mediaType === Constants_1.MessageType.document && !options.mimetype) {
            throw new Error('mimetype required to send a document');
        }
        if (mediaType === Constants_1.MessageType.sticker && options.caption) {
            throw new Error('cannot send a caption with a sticker');
        }
        if (!options.mimetype) {
            options.mimetype = Constants_1.MimetypeMap[mediaType];
        }
        let isGIF = false;
        if (options.mimetype === Constants_1.Mimetype.gif) {
            isGIF = true;
            options.mimetype = Constants_1.MimetypeMap[Constants_1.MessageType.video];
        }
        // generate a media key
        const mediaKey = Utils_1.randomBytes(32);
        const mediaKeys = Utils_2.getMediaKeys(mediaKey, mediaType);
        const enc = Utils_1.aesEncrypWithIV(buffer, mediaKeys.cipherKey, mediaKeys.iv);
        const mac = Utils_1.hmacSign(Buffer.concat([mediaKeys.iv, enc]), mediaKeys.macKey).slice(0, 10);
        const body = Buffer.concat([enc, mac]); // body is enc + mac
        const fileSha256 = Utils_1.sha256(buffer);
        // url safe Base64 encode the SHA256 hash of the body
        const fileEncSha256B64 = Utils_1.sha256(body)
            .toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/\=+$/, '');
        await Utils_2.generateThumbnail(buffer, mediaType, options);
        // send a query JSON to obtain the url & auth token to upload our media
        const json = (await this.query(['query', 'mediaConn'])).media_conn;
        const auth = json.auth; // the auth token
        let hostname = 'https://' + json.hosts[0].hostname; // first hostname available
        hostname += Constants_1.MediaPathMap[mediaType] + '/' + fileEncSha256B64; // append path
        hostname += '?auth=' + auth; // add auth token
        hostname += '&token=' + fileEncSha256B64; // file hash
        const urlFetch = await node_fetch_1.default(hostname, {
            method: 'POST',
            body: body,
            headers: { Origin: 'https://web.whatsapp.com' },
        });
        const responseJSON = await urlFetch.json();
        if (!responseJSON.url) {
            throw new Error('Upload failed got: ' + JSON.stringify(responseJSON));
        }
        const message = {};
        message[mediaType] = {
            url: responseJSON.url,
            mediaKey: mediaKey.toString('base64'),
            mimetype: options.mimetype,
            fileEncSha256: fileEncSha256B64,
            fileSha256: fileSha256.toString('base64'),
            fileLength: buffer.length,
            fileName: options.filename || 'file',
            gifPlayback: isGIF || null,
            caption: options.caption
        };
        return message;
    }
    /** Send message content */
    async sendMessageContent(id, message, options) {
        const messageJSON = this.generateWAMessage(id, message, options);
        return this.sendWAMessage(messageJSON);
    }
    /** generates a WAMessage from the given content & options */
    generateWAMessage(id, message, options) {
        if (!options.timestamp)
            options.timestamp = new Date(); // set timestamp to now
        const key = Object.keys(message)[0];
        const timestamp = options.timestamp.getTime() / 1000;
        const quoted = options.quoted;
        if (options.contextInfo)
            message[key].contextInfo = options.contextInfo;
        if (quoted) {
            const participant = quoted.key.participant || quoted.key.remoteJid;
            message[key].contextInfo = message[key].contextInfo || {};
            message[key].contextInfo.participant = participant;
            message[key].contextInfo.stanzaId = quoted.key.id;
            message[key].contextInfo.quotedMessage = quoted.message;
            // if a participant is quoted, then it must be a group
            // hence, remoteJid of group must also be entered
            if (quoted.key.participant) {
                message[key].contextInfo.remoteJid = quoted.key.remoteJid;
            }
        }
        if (!message[key].jpegThumbnail)
            message[key].jpegThumbnail = options === null || options === void 0 ? void 0 : options.thumbnail;
        const messageJSON = {
            key: {
                remoteJid: id,
                fromMe: true,
                id: Utils_1.generateMessageID(),
            },
            message: message,
            messageTimestamp: timestamp,
            messageStubParameters: [],
            participant: id.includes('@g.us') ? this.userMetaData.id : null,
            status: Constants_2.WAMessageProto.proto.WebMessageInfo.WEB_MESSAGE_INFO_STATUS.PENDING
        };
        return messageJSON;
    }
    /**
     * Send a WAMessage; more advanced functionality, you may want to stick with sendMessage()
     * */
    async sendWAMessage(message) {
        const json = ['action', { epoch: this.msgCount.toString(), type: 'relay' }, [['message', null, message]]];
        const flag = message.key.remoteJid === this.userMetaData.id ? Constants_2.WAFlag.acknowledge : Constants_2.WAFlag.ignore; // acknowledge when sending message to oneself
        const response = await this.queryExpecting200(json, [Constants_2.WAMetric.message, flag], null, message.key.id);
        return {
            status: response.status,
            messageID: message.key.id,
            message: message
        };
    }
    /**
     * Securely downloads the media from the message.
     * Renews the download url automatically, if necessary.
     */
    async downloadMediaMessage(message) {
        const fetchHeaders = { 'User-Agent': this.userAgentString };
        try {
            const buff = await Utils_2.decodeMediaMessageBuffer(message.message, fetchHeaders);
            return buff;
        }
        catch (error) {
            if (error instanceof Constants_2.BaileysError && error.status === 404) { // media needs to be updated
                this.log(`updating media of message: ${message.key.id}`, Constants_2.MessageLogLevel.info);
                await this.updateMediaMessage(message);
                const buff = await Utils_2.decodeMediaMessageBuffer(message.message, fetchHeaders);
                return buff;
            }
            throw error;
        }
    }
    /**
     * Securely downloads the media from the message and saves to a file.
     * Renews the download url automatically, if necessary.
     * @param message the media message you want to decode
     * @param filename the name of the file where the media will be saved
     * @param attachExtension should the parsed extension be applied automatically to the file
     */
    async downloadAndSaveMediaMessage(message, filename, attachExtension = true) {
        const buffer = await this.downloadMediaMessage(message);
        const extension = Utils_2.extensionForMediaMessage(message.message);
        const trueFileName = attachExtension ? (filename + '.' + extension) : filename;
        await fs_1.promises.writeFile(trueFileName, buffer);
        return trueFileName;
    }
}
exports.default = WhatsAppWebMessages;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const WAConnection_1 = __importDefault(require("../WAConnection/WAConnection"));
const Constants_1 = require("../WAConnection/Constants");
const Utils_1 = require("../WAClient/Utils");
class WhatsAppWebBase extends WAConnection_1.default {
    constructor() {
        super(...arguments);
        /** Query whether a given number is registered on WhatsApp */
        this.isOnWhatsApp = (jid) => this.query(['query', 'exist', jid]).then((m) => m.status === 200);
        /** Request an update on the presence of a user */
        this.requestPresenceUpdate = async (jid) => this.queryExpecting200(['action', 'presence', 'subscribe', jid]);
    }
    /** Set the callback for message status updates (when a message is delivered, read etc.) */
    setOnMessageStatusChange(callback) {
        const func = json => {
            json = json[1];
            let ids = json.id;
            if (json.cmd === 'ack') {
                ids = [json.id];
            }
            const data = {
                from: json.from,
                to: json.to,
                participant: json.participant,
                timestamp: new Date(json.t * 1000),
                ids: ids,
                type: (+json.ack) + 1,
            };
            callback(data);
        };
        this.registerCallback('Msg', func);
        this.registerCallback('MsgInfo', func);
    }
    /**
     * Set the callback for new/unread messages; if someone sends you a message, this callback will be fired
     * @param callbackOnMyMessages - should the callback be fired on a message you sent from the phone
     */
    setOnUnreadMessage(callbackOnMyMessages = false, callback) {
        this.registerCallback(['action', 'add:relay', 'message'], (json) => {
            const message = json[2][0][2];
            if (!message.key.fromMe || callbackOnMyMessages) {
                // if this message was sent to us, notify
                callback(message);
            }
            else {
                this.log(`[Unhandled] message - ${JSON.stringify(message)}`, Constants_1.MessageLogLevel.unhandled);
            }
        });
    }
    /** Set the callback for presence updates; if someone goes offline/online, this callback will be fired */
    setOnPresenceUpdate(callback) {
        this.registerCallback('Presence', json => callback(json[1]));
    }
    /**
     * Tell someone about your presence -- online, typing, offline etc.
     * @param jid the ID of the person/group who you are updating
     * @param type your presence
     */
    async updatePresence(jid, type) {
        const json = [
            'action',
            { epoch: this.msgCount.toString(), type: 'set' },
            [['presence', { type: type, to: jid }, null]],
        ];
        return this.queryExpecting200(json, [Constants_1.WAMetric.group, Constants_1.WAFlag.acknowledge]);
    }
    /** Query the status of the person (see groupMetadata() for groups) */
    async getStatus(jid) {
        return this.query(['query', 'Status', jid || this.userMetaData.id]);
    }
    async setStatus(status) {
        return this.setQuery([
            [
                'status',
                null,
                Buffer.from(status, 'utf-8')
            ]
        ]);
    }
    /** Get the URL to download the profile picture of a person/group */
    async getProfilePicture(jid) {
        const response = await this.queryExpecting200(['query', 'ProfilePicThumb', jid || this.userMetaData.id]);
        return response.eurl;
    }
    /** Get your contacts */
    async getContacts() {
        const json = ['query', { epoch: this.msgCount.toString(), type: 'contacts' }, null];
        const response = await this.query(json, [6, Constants_1.WAFlag.ignore]); // this has to be an encrypted query
        return response;
    }
    /** Get the stories of your contacts */
    async getStories() {
        const json = ['query', { epoch: this.msgCount.toString(), type: 'status' }, null];
        const response = await this.queryExpecting200(json, [30, Constants_1.WAFlag.ignore]);
        if (Array.isArray(response[2])) {
            return response[2].map(row => {
                var _a, _b;
                return ({
                    unread: (_a = row[1]) === null || _a === void 0 ? void 0 : _a.unread,
                    count: (_b = row[1]) === null || _b === void 0 ? void 0 : _b.count,
                    messages: Array.isArray(row[2]) ? row[2].map(m => m[2]) : []
                });
            });
        }
        return [];
    }
    /** Fetch your chats */
    async getChats() {
        const json = ['query', { epoch: this.msgCount.toString(), type: 'chat' }, null];
        return this.query(json, [5, Constants_1.WAFlag.ignore]); // this has to be an encrypted query
    }
    /** Query broadcast list info */
    async getBroadcastListInfo(jid) { return this.queryExpecting200(['query', 'contact', jid]); }
    /** Delete the chat of a given ID */
    async deleteChat(jid) {
        return this.setQuery([['chat', { type: 'delete', jid: jid }, null]], [12, Constants_1.WAFlag.ignore]);
    }
    /**
     * Check if your phone is connected
     * @param timeoutMs max time for the phone to respond
     */
    async isPhoneConnected(timeoutMs = 5000) {
        try {
            const response = await this.query(['admin', 'test'], null, timeoutMs);
            return response[1];
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Load the conversation with a group or person
     * @param count the number of messages to load
     * @param [indexMessage] the data for which message to offset the query by
     * @param [mostRecentFirst] retreive the most recent message first or retreive from the converation start
     */
    async loadConversation(jid, count, indexMessage = null, mostRecentFirst = true) {
        const json = [
            'query',
            {
                epoch: this.msgCount.toString(),
                type: 'message',
                jid: jid,
                kind: mostRecentFirst ? 'before' : 'after',
                count: count.toString(),
                index: indexMessage === null || indexMessage === void 0 ? void 0 : indexMessage.id,
                owner: (indexMessage === null || indexMessage === void 0 ? void 0 : indexMessage.fromMe) === false ? 'false' : 'true',
            },
            null,
        ];
        const response = await this.query(json, [Constants_1.WAMetric.queryMessages, Constants_1.WAFlag.ignore]);
        if (response.status)
            throw new Error(`error in query, got status: ${response.status}`);
        return response[2] ? response[2].map((item) => item[2]) : [];
    }
    /**
     * Load the entire friggin conversation with a group or person
     * @param onMessage callback for every message retreived
     * @param [chunkSize] the number of messages to load in a single request
     * @param [mostRecentFirst] retreive the most recent message first or retreive from the converation start
     */
    loadEntireConversation(jid, onMessage, chunkSize = 25, mostRecentFirst = true) {
        let offsetID = null;
        const loadMessage = async () => {
            const json = await this.loadConversation(jid, chunkSize, offsetID, mostRecentFirst);
            // callback with most recent message first (descending order of date)
            let lastMessage;
            if (mostRecentFirst) {
                for (let i = json.length - 1; i >= 0; i--) {
                    onMessage(json[i]);
                    lastMessage = json[i];
                }
            }
            else {
                for (let i = 0; i < json.length; i++) {
                    onMessage(json[i]);
                    lastMessage = json[i];
                }
            }
            // if there are still more messages
            if (json.length >= chunkSize) {
                offsetID = lastMessage.key; // get the last message
                return new Promise((resolve, reject) => {
                    // send query after 200 ms
                    setTimeout(() => loadMessage().then(resolve).catch(reject), 200);
                });
            }
        };
        return loadMessage();
    }
    async updateProfilePicture(jid, img) {
        const data = await Utils_1.generateProfilePicture(img);
        const tag = this.generateMessageTag();
        const query = [
            'picture',
            { jid: jid, id: tag, type: 'set' },
            [
                ['image', null, data.img],
                ['preview', null, data.preview]
            ]
        ];
        return this.setQuery([query], [Constants_1.WAMetric.picture, 136], tag);
    }
    /** Generic function for action, set queries */
    async setQuery(nodes, binaryTags = [Constants_1.WAMetric.group, Constants_1.WAFlag.ignore], tag) {
        const json = ['action', { epoch: this.msgCount.toString(), type: 'set' }, nodes];
        const result = await this.queryExpecting200(json, binaryTags, null, tag);
        return result;
    }
}
exports.default = WhatsAppWebBase;

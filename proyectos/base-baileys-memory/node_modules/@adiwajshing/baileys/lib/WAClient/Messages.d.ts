/// <reference types="node" />
import WhatsAppWebGroups from './Groups';
import { MessageOptions, MessageType, WALocationMessage, WAContactMessage, WASendMessageResponse, WAMessageKey, ChatModification, MessageInfo, WATextMessage } from './Constants';
import { WAMessageContent, WAMessage } from '../WAConnection/Constants';
import { proto } from '../../WAMessage/WAMessage';
export default class WhatsAppWebMessages extends WhatsAppWebGroups {
    /** Get the message info, who has read it, who its been delivered to */
    messageInfo(jid: string, messageID: string): Promise<MessageInfo>;
    /**
     * Send a read receipt to the given ID for a certain message
     * @param jid the ID of the person/group whose message you want to mark read
     * @param messageID optionally, the message ID
     * @param type whether to read or unread the message
     */
    sendReadReceipt(jid: string, messageID?: string, type?: 'read' | 'unread'): Promise<{
        status: number;
    }>;
    /**
     * Mark a given chat as unread
     * @deprecated since 2.0.0, use `sendReadReceipt (jid, null, 'unread')` instead
    */
    markChatUnread(jid: string): Promise<{
        status: number;
    }>;
    /**
     * Archive a chat
     * @deprecated since 2.0.0, use `modifyChat (jid, ChatModification.archive)` instead
    */
    archiveChat(jid: string): Promise<{
        status: number;
        stamp: string;
    }>;
    /**
     * Modify a given chat (archive, pin etc.)
     * @param jid the ID of the person/group you are modifiying
     * @param options.stamp the timestamp of pinning/muting the chat. Is required when unpinning/unmuting
     */
    modifyChat(jid: string, type: ChatModification, options?: {
        stamp: Date | string;
    }): Promise<{
        status: number;
        stamp: string;
    }>;
    loadMessage(jid: string, messageID: string): Promise<proto.WebMessageInfo>;
    /** Query a string to check if it has a url, if it does, return required extended text message */
    generateLinkPreview(text: string): Promise<proto.ExtendedTextMessage>;
    /**
     * Search WhatsApp messages with a given text string
     * @param txt the search string
     * @param inJid the ID of the chat to search in, set to null to search all chats
     * @param count number of results to return
     * @param page page number of results (starts from 1)
     */
    searchMessages(txt: string, inJid: string | null, count: number, page: number): Promise<{
        last: boolean;
        messages: proto.WebMessageInfo[];
    }>;
    /**
     * Delete a message in a chat for yourself
     * @param messageKey key of the message you want to delete
     */
    clearMessage(messageKey: WAMessageKey): Promise<{
        status: number;
    }>;
    /**
     * Fetches the latest url & media key for the given message.
     * You may need to call this when the message is old & the content is deleted off of the WA servers
     * @param message
     */
    updateMediaMessage(message: WAMessage): Promise<void>;
    /**
     * Delete a message in a chat for everyone
     * @param id the person or group where you're trying to delete the message
     * @param messageKey key of the message you want to delete
     */
    deleteMessage(id: string, messageKey: WAMessageKey): Promise<WASendMessageResponse>;
    /**
     * Forward a message like WA does
     * @param id the id to forward the message to
     * @param message the message to forward
     */
    forwardMessage(id: string, message: WAMessage): Promise<WASendMessageResponse>;
    sendMessage(id: string, message: string | WATextMessage | WALocationMessage | WAContactMessage | Buffer, type: MessageType, options?: MessageOptions): Promise<WASendMessageResponse>;
    /** Prepare a media message for sending */
    prepareMediaMessage(buffer: Buffer, mediaType: MessageType, options?: MessageOptions): Promise<proto.IMessage>;
    /** Send message content */
    sendMessageContent(id: string, message: WAMessageContent, options: MessageOptions): Promise<WASendMessageResponse>;
    /** generates a WAMessage from the given content & options */
    generateWAMessage(id: string, message: WAMessageContent, options: MessageOptions): proto.WebMessageInfo;
    /**
     * Send a WAMessage; more advanced functionality, you may want to stick with sendMessage()
     * */
    sendWAMessage(message: WAMessage): Promise<WASendMessageResponse>;
    /**
     * Securely downloads the media from the message.
     * Renews the download url automatically, if necessary.
     */
    downloadMediaMessage(message: WAMessage): Promise<Buffer>;
    /**
     * Securely downloads the media from the message and saves to a file.
     * Renews the download url automatically, if necessary.
     * @param message the media message you want to decode
     * @param filename the name of the file where the media will be saved
     * @param attachExtension should the parsed extension be applied automatically to the file
     */
    downloadAndSaveMediaMessage(message: WAMessage, filename: string, attachExtension?: boolean): Promise<string>;
}
